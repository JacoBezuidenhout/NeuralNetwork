var socket = require("socket.io");
var os = require("os");
var childProcess = require('child_process');
var path = require('path');
var thread = {
	Global: {
		MaxThreads: 16,
		LogLevel: 5,
		Port: 85498,
		NodeExecutable: "node"
	},
	WorkerPool: [],
	Queue: [],
	Events: {
		OnFinish: function() {}
	},
	Server: undefined,
	Initialize: function(Options) {
		if (Options.Port) thread.Global.Port = Options.Port;
		if (Options.MaxThreads) thread.Global.MaxThreads = Options.MaxThreads;
		if (Options.NodeExecutable) thread.Global.NodeExecutable = Options.NodeExecutable;
		if (Options.LogLevel) thread.Global.LogLevel = Options.LogLevel;
		thread.Server = socket.listen(thread.Global.Port);
		thread.Server.set("log level", 1);
		thread.Server.sockets.on("connection", function (socket) {
			socket.on("Boot", function (data) {
				thread.Work(socket, data);
			});
			socket.on("Result", function (data) {
				console.log("Worker "+data.id+": "+data.result);
				thread.Work(socket, data);
			});
		});
	},
	Work: function(socket, data) {
		if (thread.Queue.length > 0) {
			socket.emit("Work",{
				task: thread.Queue[0].Task,
				index: data.id
			});
			thread.Queue = thread.Queue.slice(1);
			console.log("Worker "+data.id+": Grabbed Task from Queue, "+thread.Queue.length+" remaining");
			if (thread.Queue.length === 0) {
				console.log("Queue empty");
			}
		} else {
			console.log("Queue empty");
			thread.WorkerPool[data.id].state = 0;
			var gState = 0;
			thread.WorkerPool.forEach(function(Worker) {
				gState += Worker.state;
			});
			if (gState === 0) {
				thread.Events.OnFinish();
			}
		}
	},
	CreateThread: function(Task) {
		if (!Task) return false;
		thread.Queue.push(Task);
		thread.Server.emit("Add", {});
		var index = thread.WorkerPool.length;
		if (index < thread.Global.MaxThreads) {
			var basePath = path.join(__dirname, "..", "lib", "ThreadBase.js");
			var p = ["node", basePath, thread.Global.Port, index];
			var process = childProcess.exec(p.join(" "), function (error, stdout, stderr) {
				console.log("Worker "+index+": stdout: "+stdout);
				console.log("Worker "+index+": stderr: "+stderr);
			});
			process.on('exit', function (code) {
				console.log("Worker "+index+": Finished or exited with code "+code);
			});
			thread.WorkerPool.push({
				state: 1
			});
			console.log("Created Worker Thread "+index);
		}
		return true;
	},
	End: function() {
		thread.Server.emit("End", {});
		// thread.server.close();
	},
	BaseTask: function(Task) {
		this.Task = "" + Task;
		this.OnExit = function() {};
	}
};
module.exports = thread;
